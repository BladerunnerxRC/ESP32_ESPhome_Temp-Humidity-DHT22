# ESPhome configuration for the ENVIRO-B2 ESP32 board.
#
# works on INFO ESPHome 22025.11.3 and greater 9.3 FW for HW
#   - ESP32-D0WDQ6 (revision v1.0)
#   - Features: WiFi, BT, Dual Core, Coding Scheme None
#   - 40MHz crystal
#   - 4MB flash

# ┌───────────────────────────────────────────────┐
# │         GPIO Pin Assignment Table             │
# ├─────────────┬─────────────────────────────────┤
# │ GPIO Number │ Function                        │
# ├─────────────┼─────────────────────────────────┤
# │ GPI26       │ DHT22 Data                      │
# │ GPI21       │ I²C SDA (OLED Display)          │
# │ GPI22       │ I²C SCL (OLED Display)          │
# │ GPIO2       │ Status LED (optional - Internal)│
# │ GPIO16      │ WiFi Signal Sensor (internal)   │
# └─────────────┴─────────────────────────────────┘
#
# Notes:
# - OLED uses SSD1306 128x32 over I²C at address 0x3C
# - DHT22 sensor reports temperature and humidity
# - WiFi signal strength is reported via ESP internal sensor

substitutions:
  # Calibration offsets applied to the DHT22 readings
  temperature_calibration: "0.0"
  humidity_calibration: "0.0"
  # Measurement intervals
  update_interval_s: "30s"
  update_interval_wifi: "60s"

globals:
  - id: g_temperature_calibration
    type: float
    restore_value: true
    initial_value: "${temperature_calibration}"
  - id: g_humidity_calibration
    type: float
    restore_value: true
    initial_value: "${humidity_calibration}"
  - id: g_update_interval_s
    type: int
    restore_value: true
    initial_value: "30"
  - id: g_update_interval_wifi
    type: int
    restore_value: true
    initial_value: "60"
  - id: g_wifi_connected
    type: bool
    restore_value: false
    initial_value: 'false'

esphome:
  name: "enviro-b2"
  friendly_name: ENVIRO-B2
  on_boot:
    priority: -100
    then:
      - lambda: |-
          id(g_update_interval_s) = atoi("${update_interval_s}");
          id(g_update_interval_wifi) = atoi("${update_interval_wifi}");

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    version: recommended # Options: recommended, dev, or latest

# Enable detailed logging. UART output is disabled because the serial port
# is not used in normal operation.
logger:
  level: DEBUG # Options: ERROR, WARN, INFO, DEBUG, VERY_VERBOSE
  baud_rate: 115200 # enable UART logging for debugging
  # baud_rate: 0 # disable UART logging

# Enable the Home Assistant API with encrypted communication
api:
  encryption:
    key: !secret enviro_b2_api_key

# Over-the-air update credentials
ota:
  - platform: esphome
    password: !secret enviro_b2_ota_pwd

# Use Home Assistant as the time source
time:
  - platform: homeassistant
    id: ha_time

wifi:
  # Wi-Fi credentials
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none
  output_power: 15.5dB
  # Static network configuration
  manual_ip:
    static_ip: 10.100.50.77
    gateway: 10.100.50.1
    subnet: 255.255.255.0
    dns1: 8.8.8.8
    dns2: 8.8.4.4
  # Turn on the LED when connected and restart the board if the connection is lost.
  # This will also create a persistent notification in Home Assistant.
  # If the connection is lost for more than 30 seconds, the device will restart.
  on_connect:
    then:
      - lambda: 'id(g_wifi_connected) = true;'
      - component.update: enviro_oled     # redraw now
      - switch.turn_on: onboard_led
      - logger.log: "WiFi connected"
      - homeassistant.service:
          service: persistent_notification.create
          data:
            title: "ENVIRO-B2"
            message: "WiFi connection established"

  # Handle disconnection: wait 30s, then only restart if still offline
  on_disconnect:
    then:
      - lambda: 'id(g_wifi_connected) = false;'
      - component.update: enviro_oled     # hide icon immediately
      - switch.turn_off: onboard_led
      - logger.log: "WiFi disconnected. Waiting 30 seconds before restart."
      - delay: 30s
      - if:
          condition:
            wifi.connected: {}
          then:
            - logger.log: "WiFi reconnected during delay, not restarting."
          else:
            - logger.log: "Still disconnected, restarting now."
            - switch.turn_on: reboot_enviro_b2_restart

  # Fallback access point settings
  ap:
    ssid: !secret enviro_b2_ap_sid
    password: !secret enviro_b2_ap_pwd

i2c:
  sda: GPIO21
  scl: GPIO22
  scan: false
  frequency: 400kHz

font:
  - file: "gfonts://Roboto"
    id: oled_font_large
    size: 20
  - file: "gfonts://Roboto"
    id: oled_font_small
    size: 10

# create directory homeassistant/esphome/images and upload to folder for compiling
image:
  - file: "images/wifi.png"
    id: img_wifi
    resize: 19x16
    type: BINARY

display:
  - platform: ssd1306_i2c
    id: enviro_oled
    model: "SSD1306 128x32"
    address: 0x3C
    update_interval: ${update_interval_s}
    lambda: |-
      it.fill(Color::BLACK);

      if (id(temp).has_state()) {
        const float temp_f = id(temp).state * 1.8f + 32.0f;
        it.printf(0, 0, id(oled_font_small), "Temp: %.1f°F", temp_f);
      } else {
        it.print(0, 0, id(oled_font_small), "Temp: --°F");
      }

      if (id(humidity).has_state()) {
        it.printf(0, 11, id(oled_font_small), "Humidity: %.1f%%", id(humidity).state);
      } else {
        it.print(0, 11, id(oled_font_small), "Humidity: --%");
      }

      if (id(wifi_signal_dbm).has_state()) {
        it.printf(0, 22, id(oled_font_small), "WiFi: %.0f dBm", id(wifi_signal_dbm).state);
      } else {
        it.print(0, 22, id(oled_font_small), "WiFi: -- dBm");
      }

      // Only show the Wi-Fi icon when connected
      if (id(g_wifi_connected)) {
        // center vertically: (32-16)/2 = 8; right-align: 128-19-3 = 106 (3px margin)
        it.image(106, 8, id(img_wifi), Color(255, 255, 255));
      }
      // else: do not show the icon when not connected


# captive_portal: # (Optional) Enable captive portal for fallback AP

sensor:
  # Report Wi-Fi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_dbm
    update_interval: never # Turn native intervals off to use Interval Triggers
    device_class: signal_strength

  # Temperature and humidity from a DHT22 sensor
  - platform: dht
    id: dht22_component
    pin: 
      number: GPIO26
      mode: INPUT_PULLUP        # helps if your external pull-up is marginal
    model: DHT22
    temperature:
      name: "DHT22_Temperature"
      id: temp
      accuracy_decimals: 1
      filters:  # DHT median + clamp + NaN filter
        - filter_out: nan
        - clamp:
            min_value: -40
            max_value: 80
        - median:
            window_size: 5
            send_every: 1
            send_first_at: 1
        - lambda: |-
            if (isnan(x)) return x;
            return x + id(g_temperature_calibration);
    humidity:
      name: "DHT22_Humidity"
      id: humidity
      accuracy_decimals: 1
      filters: # DHT median + clamp + NaN filter
        - filter_out: nan
        - clamp:
            min_value: 0
            max_value: 100
        - median:
            window_size: 5
            send_every: 1
            send_first_at: 1
        - lambda: |-
            if (isnan(x)) return x;
            return x + id(g_humidity_calibration);
    update_interval: never # ${update_interval_s}

  # How long the device has been running
  - platform: uptime
    id: enviro_b2_uptime_sensor
    name: "ENVIRO-B2 Uptime"

# runtime-tunable rates that use globals
interval:
  - interval: 1s
    then:
      - lambda: |-
          static uint32_t last = 0;
          const uint32_t now = millis() / 1000;
          if (now - last >= id(g_update_interval_s)) {
            last = now;
            id(dht22_component).update();
          }

  - interval: 1s
    then:
      - lambda: |-
          static uint32_t last_wifi = 0;
          const uint32_t now = millis() / 1000;
          if (now - last_wifi >= id(g_update_interval_wifi)) {
            last_wifi = now;
            id(wifi_signal_dbm).update();
          }

binary_sensor:
  # Show if the device is online
  - platform: status
    name: "Connection Status"
    id: connection_status
    entity_category: diagnostic

  # Trigger a reboot from Home Assistant when the input_boolean is toggled
  - platform: homeassistant
    name: "Reboot ENVIRO-B2 Trigger"
    entity_id: input_boolean.reboot_enviro_b2
    id: reboot_trigger
    on_press:
      - if:
          condition:
            lambda: 'return id(enviro_b2_uptime_sensor).state > 60;'
          then:
            - logger.log: "Manual reboot requested via Home Assistant (passes debounce)"
            # Feedback blink removed for simplicity
            - homeassistant.service:
                service: input_boolean.turn_off
                data:
                  entity_id: input_boolean.reboot_enviro_b2
            - logger.log: "Device rebooting now"
            - switch.turn_on: reboot_enviro_b2_restart
          else:
            - logger.log: "Debounce blocked reboot: uptime too short"
            - homeassistant.service:
                service: input_boolean.turn_off
                data:
                  entity_id: input_boolean.reboot_enviro_b2

switch:
  # Controls the onboard LED connected to GPIO2
  - platform: gpio
    name: "Wifi Connect LED Switch"
    pin: 2
    id: onboard_led
    inverted: false # Adjust if LED logic is inverted

  # Exposes a restart switch
  - platform: restart
    name: "Reboot_ENVIRO-B2"
    id: reboot_enviro_b2_restart

button:
  - platform: template
    name: "Refresh Sensors"
    id: refresh_sensors
    on_press:
      - component.update: dht22_component
      - component.update: wifi_signal_dbm
      - component.update: enviro_b2_uptime_sensor

number:
  - platform: template
    name: "Temperature Calibration"
    id: temperature_calibration_number
    min_value: -10
    max_value: 10
    step: 0.1
    restore_value: true
    initial_value: ${temperature_calibration}
    set_action:
      - globals.set:
          id: g_temperature_calibration
          value: !lambda 'return x;'
      - button.press: refresh_sensors

  - platform: template
    name: "Humidity Calibration"
    id: humidity_calibration_number
    min_value: -10
    max_value: 10
    step: 0.1
    restore_value: true
    initial_value: ${humidity_calibration}
    set_action:
      - globals.set:
          id: g_humidity_calibration
          value: !lambda 'return x;'
      - button.press: refresh_sensors

  - platform: template
    name: "Update Interval (s)"
    id: update_interval_seconds_number
    min_value: 10
    max_value: 3600
    step: 1
    restore_value: true
    initial_value: 30
    set_action:
      - globals.set:
          id: g_update_interval_s
          value: !lambda 'return (int)x;'
      - button.press: refresh_sensors

  - platform: template
    name: "WiFi Update Interval (s)"
    id: update_interval_wifi_seconds_number
    min_value: 10
    max_value: 3600
    step: 1
    restore_value: true
    initial_value: 60
    set_action:
      - globals.set:
          id: g_update_interval_wifi
          value: !lambda 'return (int)x;'
      - button.press: refresh_sensors
